//! Configuration file generation

use uuid::Uuid;

/// Erasure coding profile configuration
#[derive(Debug, Clone)]
pub struct EcProfile {
    /// Number of data shards (k)
    pub k: u32,
    /// Number of parity shards (m)
    pub m: u32,
}

impl EcProfile {
    /// Create from k+m string like "4+2" or "2+1"
    pub fn from_str(s: &str) -> Option<Self> {
        let parts: Vec<&str> = s.split('+').collect();
        if parts.len() != 2 {
            return None;
        }
        let k = parts[0].parse().ok()?;
        let m = parts[1].parse().ok()?;
        Some(Self { k, m })
    }

    /// Minimum disks required for this profile
    pub fn min_disks(&self) -> u32 {
        self.k + self.m
    }

    /// Common presets
    pub fn preset_2_1() -> Self { Self { k: 2, m: 1 } }  // 3 disks, 66% efficiency
    pub fn preset_4_2() -> Self { Self { k: 4, m: 2 } }  // 6 disks, 66% efficiency
    pub fn preset_8_4() -> Self { Self { k: 8, m: 4 } }  // 12 disks, 66% efficiency
    pub fn preset_replication() -> Self { Self { k: 1, m: 2 } } // 3-way replication
}

impl Default for EcProfile {
    fn default() -> Self {
        Self::preset_4_2()
    }
}

/// Gateway configuration options
#[derive(Debug, Clone)]
pub struct GatewayConfig {
    pub listen: String,
    pub meta_endpoint: String,
    pub osd_endpoint: String,
    pub ec_profile: EcProfile,
    pub auth_enabled: bool,
    pub region: String,
    pub admin_user: String,
    pub log_level: String,
}

impl Default for GatewayConfig {
    fn default() -> Self {
        Self {
            listen: "0.0.0.0:9000".to_string(),
            meta_endpoint: "http://localhost:9001".to_string(),
            osd_endpoint: "http://localhost:9002".to_string(),
            ec_profile: EcProfile::default(),
            auth_enabled: true,
            region: "us-east-1".to_string(),
            admin_user: "admin".to_string(),
            log_level: "info".to_string(),
        }
    }
}

/// Generate gateway configuration
pub fn generate_gateway_config(meta_endpoint: &str) -> String {
    let config = GatewayConfig {
        meta_endpoint: meta_endpoint.to_string(),
        ..Default::default()
    };
    generate_gateway_config_full(&config)
}

/// Generate gateway configuration with full options
pub fn generate_gateway_config_full(config: &GatewayConfig) -> String {
    let auth_str = if config.auth_enabled { "true" } else { "false" };
    format!(
        r#"# ObjectIO Gateway Configuration
# Generated by objectio-install

[gateway]
# Listen address for S3 API
listen = "{listen}"

# Metadata service endpoint
meta_endpoint = "{meta_endpoint}"

# Initial OSD endpoint (additional OSDs discovered via metadata)
osd_endpoint = "{osd_endpoint}"

[erasure]
# Erasure coding configuration
# k = number of data shards
# m = number of parity shards
# Common profiles:
#   2+1: 3 disks minimum, 66% storage efficiency, tolerates 1 failure
#   4+2: 6 disks minimum, 66% storage efficiency, tolerates 2 failures (default)
#   8+4: 12 disks minimum, 66% storage efficiency, tolerates 4 failures
#   1+2: 3-way replication, 33% efficiency, tolerates 2 failures
k = {k}
m = {m}

[auth]
# Enable authentication (set to false for development)
enabled = {auth_str}

# AWS region for SigV4 verification
region = "{region}"

# Admin user name
admin_user = "{admin_user}"

[logging]
level = "{log_level}"
"#,
        listen = config.listen,
        meta_endpoint = config.meta_endpoint,
        osd_endpoint = config.osd_endpoint,
        k = config.ec_profile.k,
        m = config.ec_profile.m,
        auth_str = auth_str,
        region = config.region,
        admin_user = config.admin_user,
        log_level = config.log_level,
    )
}

/// Generate metadata service configuration
pub fn generate_meta_config(raft_peers: &[String]) -> String {
    let node_id = Uuid::new_v4();
    let peers_str = if raft_peers.is_empty() {
        "# No peers configured - single node mode".to_string()
    } else {
        format!("peers = {:?}", raft_peers)
    };

    format!(
        r#"# ObjectIO Metadata Service Configuration
# Generated by objectio-install

[meta]
# Unique node ID
node_id = "{node_id}"

# Listen address for gRPC
listen = "0.0.0.0:9001"

# Data directory for Raft and metadata storage
data_dir = "/var/lib/objectio/meta"

[raft]
# Raft cluster configuration
{peers_str}

# Election timeout (milliseconds)
election_timeout_min = 150
election_timeout_max = 300

# Heartbeat interval (milliseconds)
heartbeat_interval = 50

[storage]
# Metadata database path
db_path = "/var/lib/objectio/meta/metadata.db"

[logging]
level = "info"
"#
    )
}

/// Generate OSD configuration
///
/// block_size_bytes: Storage block size in bytes (default 4MB = 4194304)
pub fn generate_osd_config(disks: &[String], meta_endpoint: &str) -> String {
    generate_osd_config_with_block_size(disks, meta_endpoint, 4194304)
}

/// Generate OSD configuration with custom block size
pub fn generate_osd_config_with_block_size(disks: &[String], meta_endpoint: &str, block_size_bytes: u32) -> String {
    let node_id = Uuid::new_v4();
    let disks_str = disks
        .iter()
        .map(|d| format!("\"{}\"", d))
        .collect::<Vec<_>>()
        .join(", ");

    format!(
        r#"# ObjectIO OSD Configuration
# Generated by objectio-install

[osd]
# Unique node ID
node_id = "{node_id}"

# Listen address for gRPC
listen = "0.0.0.0:9002"

# Metadata service endpoint
meta_endpoint = "{meta_endpoint}"

[storage]
# Disk paths to use for storage
disks = [{disks_str}]

# Block size for storage
# Larger block sizes support larger objects without multipart upload
# Default: 4194304 (4MB)
block_size = {block_size_bytes}

[cache]
# Block cache configuration
enabled = true
size_mb = 256
policy = "write_through"

[logging]
level = "info"
"#
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_gateway_config() {
        let config = generate_gateway_config("http://localhost:9001");
        assert!(config.contains("meta_endpoint"));
        assert!(config.contains("listen"));
    }

    #[test]
    fn test_meta_config() {
        let config = generate_meta_config(&[]);
        assert!(config.contains("node_id"));
        assert!(config.contains("single node mode"));

        let config_with_peers = generate_meta_config(&["node1:9001".to_string(), "node2:9001".to_string()]);
        assert!(config_with_peers.contains("peers"));
    }

    #[test]
    fn test_osd_config() {
        let config = generate_osd_config(&["/dev/sdb".to_string()], "http://localhost:9001");
        assert!(config.contains("/dev/sdb"));
        assert!(config.contains("meta_endpoint"));
    }
}
